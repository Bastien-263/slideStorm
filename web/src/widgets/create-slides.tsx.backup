import "@/index.css";
import { useState, useRef, useEffect } from "react";
import { mountWidget } from "skybridge/web";
import * as pdfjsLib from "pdfjs-dist";
import React from 'react';
import ReactDOM from 'react-dom/client';
import Frame, { FrameContextConsumer } from 'react-frame-component';
import * as LucideIcons from 'lucide-react';

// Configure PDF.js worker
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@5.4.530/build/pdf.worker.min.mjs';

function PdfUploader() {
  const [slideDescription, setSlideDescription] = useState("");
  const [pdfFile, setPdfFile] = useState<File | null>(null);
  const [pngFiles, setPngFiles] = useState<File[]>([]);
  const [isConverting, setIsConverting] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [tsxFileContent, setTsxFileContent] = useState<string | null>(null);
  const [tsxFileName, setTsxFileName] = useState<string | null>(null);
  const [renderError, setRenderError] = useState<string | null>(null);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const fullscreenContainerRef = useRef<HTMLDivElement>(null);
  const frameRef = useRef<any>(null);

  const workspaceId = import.meta.env.VITE_WORKSPACE_ID;
  const agentId = import.meta.env.VITE_AGENT_ID;
  const proxyUrl = import.meta.env.VITE_PROXY_URL || 'http://localhost:3000';

  // Handle fullscreen changes
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
  }, []);

  // Forward keyboard events to iframe for navigation (only in fullscreen)
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!isFullscreen) return;

      const target = e.target as HTMLElement;
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') return;

      if (['ArrowLeft', 'ArrowRight', 'PageUp', 'PageDown', 'Home', 'End', ' '].includes(e.key)) {
        e.preventDefault();
        
        // Try to find and click navigation buttons in the frame
        if (frameRef.current?.node?.contentWindow) {
          const iframeDoc = frameRef.current.node.contentWindow.document;
          const allButtons = iframeDoc.querySelectorAll('button, [role="button"]');

          const matchesButton = (btn: Element, keywords: string[]) => {
            const text = btn.textContent?.toLowerCase() || '';
            const ariaLabel = btn.getAttribute('aria-label')?.toLowerCase() || '';
            return keywords.some(keyword => text.includes(keyword) || ariaLabel.includes(keyword));
          };

          let targetButton: Element | null = null;

          if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
            for (const btn of allButtons) {
              if (matchesButton(btn, ['prev', 'prÃ©cÃ©d', 'previous', 'back'])) {
                targetButton = btn;
                break;
              }
            }
          } else if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ') {
            for (const btn of allButtons) {
              if (matchesButton(btn, ['next', 'suiv', 'suivant', 'forward'])) {
                targetButton = btn;
                break;
              }
            }
          }

          if (targetButton) {
            (targetButton as HTMLElement).click();
          }
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isFullscreen]);

  const toggleFullscreen = async () => {
    if (!fullscreenContainerRef.current) return;

    try {
      if (!document.fullscreenElement) {
        await fullscreenContainerRef.current.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    } catch (err) {
      console.error('Fullscreen error:', err);
    }
  };

  const callDustAPI = async (url: string, body: any, method: string = 'POST', returnText: boolean = false) => {
    if (body instanceof FormData) {
      body.append('url', url);
      const response = await fetch(`${proxyUrl}/widgets/api/dust-upload`, {
        method: 'POST',
        body,
      });
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Upload error:', response.status, errorText);
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    }

    const response = await fetch(`${proxyUrl}/widgets/api/dust-proxy`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ url, body, method, returnText })
    });
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Proxy error:', { url, method, status: response.status, error: errorText });
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return returnText ? response.text() : response.json();
  };

  const convertPdfToPng = async (file: File) => {
    setPdfFile(file);
    setIsConverting(true);
    setError(null);

    try {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

      const pngFilesArray: File[] = [];

      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2 });

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;

        if (context) {
          await page.render({ canvasContext: context, viewport } as any).promise;

          const blob = await new Promise<Blob>((resolve) => {
            canvas.toBlob((blob) => resolve(blob!), 'image/png');
          });

          const pngFile = new File([blob], `${file.name.replace('.pdf', '')}_page_${pageNum}.png`, { type: 'image/png' });
          pngFilesArray.push(pngFile);
        }
      }

      setPngFiles(pngFilesArray);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Unknown error');
    } finally {
      setIsConverting(false);
    }
  };

  const streamAgentResponse = async (convId: string, messageContent: string) => {
    try {
      const messageUrl = `https://dust.tt/api/v1/w/${workspaceId}/assistant/conversations/${convId}/messages`;
      await callDustAPI(messageUrl, {
        content: messageContent,
        mentions: agentId ? [{ configurationId: agentId }] : [],
        context: { username: 'slidestorm', timezone: 'Europe/Paris' }
      });

      const streamUrl = `https://dust.tt/api/v1/w/${workspaceId}/assistant/conversations/${convId}/events`;
      const response = await fetch(`${proxyUrl}/widgets/api/dust-stream`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ url: streamUrl })
      });

      if (!response.ok) throw new Error(`Stream error: ${response.status}`);
      if (!response.body) throw new Error('No response body');

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      let agentDone = false;

      while (!agentDone) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || "";

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const jsonStr = line.slice(6).trim();
            if (!jsonStr || jsonStr === 'done') continue;

            try {
              const event = JSON.parse(jsonStr);
              const data = event.data;

              if (data.type === 'agent_message_done') {
                agentDone = true;
                break;
              }
            } catch (e) {
              // Skip invalid JSON
            }
          }
        }
      }

      const convDetailsUrl = `https://dust.tt/api/v1/w/${workspaceId}/assistant/conversations/${convId}`;
      const convDetails = await callDustAPI(convDetailsUrl, null, 'GET');

      const agentMessages = convDetails.conversation?.content
        ?.flat()
        .filter((item: any) => item.type === 'agent_message') || [];

      for (const msg of agentMessages) {
        for (const action of msg.actions || []) {
          if (action.functionCallName === 'interactive_content__create_interactive_content_file'
              && action.generatedFiles?.length > 0) {

            const file = action.generatedFiles[0];
            const fileId = file.fileId || file.sId;

            const fileUrl = `https://dust.tt/api/v1/w/${workspaceId}/files/${fileId}`;
            const fileContent = await callDustAPI(fileUrl, null, 'GET', true);

            console.log(`âœ… Slides created successfully! View conversation: https://dust.tt/w/${workspaceId}/assistant/${convId}`);

            setTsxFileContent(fileContent);
            setTsxFileName(file.title || 'generated.tsx');

            // Update the last assistant message with slides
            setMessages(prev => {
              const updated = [...prev];
              const lastMsg = updated[updated.length - 1];
              if (lastMsg && lastMsg.role === 'assistant') {
                lastMsg.content = 'Your slides are ready!';
                lastMsg.isGenerating = false;
                lastMsg.hasSlides = true;
              }
              return updated;
            });
            break;
          }
        }
      }
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Stream error');
      setMessages(prev => [...prev, {
        id: Date.now().toString(),
        role: 'assistant',
        content: `Error: ${error instanceof Error ? error.message : 'Stream error'}`,
        timestamp: new Date()
      }]);
    }
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    if (file.type === "application/pdf") {
      convertPdfToPng(file);
    } else if (file.type === "image/png") {
      setPdfFile(file);
      setPngFiles([file]);
    } else if (file.type === "application/vnd.ms-powerpoint" || file.type === "application/vnd.openxmlformats-officedocument.presentationml.presentation") {
      setPdfFile(file);
      setPngFiles([file]);
    } else {
      setError("Please select a PDF, PNG, or PowerPoint file");
      return;
    }
  };

  const handleGenerate = async () => {
    if (!slideDescription.trim()) return;

    setIsGenerating(true);
    setError(null);

    try {
      const conversationUrl = `https://dust.tt/api/v1/w/${workspaceId}/assistant/conversations`;
      const conversationJson = await callDustAPI(conversationUrl, {
        visibility: 'unlisted',
        title: null
      });
      const convId = conversationJson.conversation?.sId;
      if (!convId) throw new Error('Failed to create conversation');

      for (const file of pngFiles) {
        let contentType = 'image/png';
        if (file.type === 'application/vnd.ms-powerpoint') {
          contentType = 'application/vnd.ms-powerpoint';
        } else if (file.type === 'application/vnd.openxmlformats-officedocument.presentationml.presentation') {
          contentType = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
        }

        const fileCreateResponse = await callDustAPI(
          `https://dust.tt/api/v1/w/${workspaceId}/files`,
          {
            contentType: contentType,
            fileName: file.name,
            fileSize: file.size,
            useCase: 'conversation',
            useCaseMetadata: { conversationId: convId }
          }
        );
        const fileId = fileCreateResponse.file?.sId;
        if (!fileId) throw new Error('Failed to create file entry');

        const formData = new FormData();
        formData.append('file', file);
        await callDustAPI(`https://dust.tt/api/v1/w/${workspaceId}/files/${fileId}`, formData);

        await callDustAPI(
          `https://dust.tt/api/v1/w/${workspaceId}/assistant/conversations/${convId}/content_fragments`,
          { title: file.name, fileId }
        );
      }

      const assistantMessage: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: 'Generating your slides...',
        timestamp: new Date(),
        isGenerating: true
      };
      setMessages(prev => [...prev, assistantMessage]);

      setIsSending(false);
      await streamAgentResponse(convId, messageContent);
    } catch (error) {
      console.error('Error:', error);
      setError(error instanceof Error ? error.message : 'Unknown error');
      setMessages(prev => [...prev, {
        id: (Date.now() + 2).toString(),
        role: 'assistant',
        content: `Error: ${error instanceof Error ? error.message : 'Unknown error'}`,
        timestamp: new Date()
      }]);
    } finally {
      setIsSending(false);
    }
  };

  // Slides viewer component
  const SlidesViewer = () => (
    <div style={{
      marginTop: "16px",
      borderRadius: "12px",
      overflow: "hidden",
      border: "1px solid #e5e7eb"
    }}>
      <div style={{
        padding: "12px 16px",
        background: "#f9fafb",
        borderBottom: "1px solid #e5e7eb",
        display: "flex",
        gap: "8px",
        alignItems: "center",
        justifyContent: "space-between"
      }}>
        <span style={{ fontSize: "14px", fontWeight: "500", color: "#374151" }}>
          {tsxFileName}
        </span>
        <div style={{ display: "flex", gap: "8px" }}>
          <button
            onClick={toggleFullscreen}
            style={{
              padding: "6px 12px",
              background: "#10a37f",
              color: "white",
              border: "none",
              borderRadius: "6px",
              fontSize: "13px",
              cursor: "pointer",
              fontWeight: "500"
            }}
          >
            {isFullscreen ? 'âœ• Exit' : 'â›¶ Present'}
          </button>
          <button
            onClick={() => {
              navigator.clipboard.writeText(tsxFileContent!);
              alert('Code copied!');
            }}
            style={{
              padding: "6px 12px",
              background: "#6b7280",
              color: "white",
              border: "none",
              borderRadius: "6px",
              fontSize: "13px",
              cursor: "pointer",
              fontWeight: "500"
            }}
          >
            Copy
          </button>
        </div>
      </div>

      <div
        ref={fullscreenContainerRef}
        style={{
          background: isFullscreen ? "#000" : "#f5f5f5",
          padding: isFullscreen ? "0" : "20px",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          width: isFullscreen ? "100vw" : "auto",
          height: isFullscreen ? "100vh" : "auto"
        }}
      >
        <div style={{
          width: "100%",
          maxWidth: isFullscreen ? "none" : "100%",
          aspectRatio: "16 / 9",
          position: "relative",
          height: isFullscreen ? "100%" : "auto"
        }}>
          <Frame
            ref={frameRef}
            style={{
              position: "absolute",
              top: 0,
              left: 0,
              width: "100%",
              height: "100%",
              border: "none",
              background: "white"
            }}
            initialContent={`
              <!DOCTYPE html>
              <html lang="en">
                <head>
                  <meta charset="UTF-8">
                  <meta name="viewport" content="width=device-width, initial-scale=1.0">
                  <script src="https://cdn.tailwindcss.com"></script>
                  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
                  <style>
                    body {
                      margin: 0;
                      padding: 0;
                      overflow: hidden;
                      background: #000;
                      display: flex;
                      align-items: center;
                      justify-content: center;
                      min-height: 100vh;
                    }
                    #root {
                      aspect-ratio: 16 / 9;
                      width: 100%;
                      max-width: 100vw;
                      max-height: 100vh;
                      overflow: hidden;
                      background: white;
                      position: relative;
                    }
                    #root > * {
                      width: 100%;
                      height: 100%;
                      overflow: hidden;
                      box-sizing: border-box;
                    }
                  </style>
                </head>
                <body>
                  <div id="root"></div>
                </body>
              </html>
            `}
          >
            <FrameContextConsumer>
              {({ document: iframeDoc, window: iframeWindow }: any) => {
                if (!iframeDoc || !iframeWindow) return null;

                try {
                  (iframeWindow as any).React = React;
                  (iframeWindow as any).ReactDOM = ReactDOM;

                  const protectedProps = new Set([
                    'Infinity', 'NaN', 'undefined', 'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt',
                    'Object', 'Function', 'Boolean', 'Symbol', 'Error', 'Number', 'Date',
                    'String', 'RegExp', 'Array', 'Map', 'Set', 'Promise',
                    'Math', 'JSON', 'console', 'window', 'document', 'navigator', 'location'
                  ]);

                  Object.entries(LucideIcons).forEach(([name, Component]) => {
                    if (!protectedProps.has(name)) {
                      try {
                        (iframeWindow as any)[name] = Component;
                      } catch (e) {
                        console.warn(`Could not assign icon: ${name}`);
                      }
                    }
                  });

                  (iframeWindow as any).useState = React.useState;
                  (iframeWindow as any).useEffect = React.useEffect;
                  (iframeWindow as any).useMemo = React.useMemo;
                  (iframeWindow as any).useCallback = React.useCallback;

                  (iframeWindow as any).Button = ({ children, variant, size, disabled, className = '', onClick, ...props }: any) => {
                    const baseClasses = 'inline-flex items-center justify-center transition-all';
                    const variantClasses = variant === 'outline' ? 'border border-current' : '';
                    const sizeClasses = size === 'icon' ? 'p-2' : size === 'lg' ? 'px-6 py-3' : 'px-4 py-2';
                    const disabledClasses = disabled ? 'opacity-30 cursor-not-allowed' : 'cursor-pointer';
                    return React.createElement('button', {
                      onClick: !disabled ? onClick : undefined,
                      disabled,
                      className: `${baseClasses} ${variantClasses} ${sizeClasses} ${disabledClasses} ${className}`,
                      ...props
                    }, children);
                  };

                  (iframeWindow as any).Card = ({ children, className = '', ...props }: any) => {
                    return React.createElement('div', {
                      className: `bg-white rounded-lg shadow-md ${className}`,
                      ...props
                    }, children);
                  };

                  (iframeWindow as any).CardHeader = ({ children, className = '', ...props }: any) => {
                    return React.createElement('div', {
                      className: `p-6 ${className}`,
                      ...props
                    }, children);
                  };

                  (iframeWindow as any).CardTitle = ({ children, className = '', ...props }: any) => {
                    return React.createElement('h3', {
                      className: `text-2xl font-bold ${className}`,
                      ...props
                    }, children);
                  };

                  (iframeWindow as any).CardContent = ({ children, className = '', ...props }: any) => {
                    return React.createElement('div', {
                      className: `p-6 pt-0 ${className}`,
                      ...props
                    }, children);
                  };

                  let code = tsxFileContent!;
                  code = code.replace(/^import\s+.*?from\s+["'].*?["'];?\s*$/gm, '');
                  code = code.replace(/^export\s+default\s+/gm, '').replace(/^export\s+(const|function|class)\s+/gm, '$1 ');

                  const Babel = (iframeWindow as any).Babel;
                  if (!Babel) {
                    throw new Error('Babel not loaded in iframe');
                  }

                  const transformedCode = Babel.transform(code, {
                    presets: ['typescript', 'react'],
                    filename: 'component.tsx'
                  }).code;

                  const componentMatch = code.match(/(?:const|function)\s+(\w+)\s*=?\s*(?:\(\)|=>|\()/);
                  const componentName = componentMatch ? componentMatch[1] : null;

                  if (componentName) {
                    const lucideIconNames = Object.keys(LucideIcons);
                    const lucideIconComponents = Object.values(LucideIcons);

                    const componentFactory = new Function(
                      'React', 'useState', 'useEffect', 'useMemo', 'useCallback',
                      ...lucideIconNames,
                      'Button', 'Card', 'CardHeader', 'CardTitle', 'CardContent',
                      `${transformedCode}\nreturn ${componentName};`
                    );

                    const Component = componentFactory(
                      React, React.useState, React.useEffect, React.useMemo, React.useCallback,
                      ...lucideIconComponents,
                      (iframeWindow as any).Button,
                      (iframeWindow as any).Card,
                      (iframeWindow as any).CardHeader,
                      (iframeWindow as any).CardTitle,
                      (iframeWindow as any).CardContent
                    );

                    const rootElement = iframeDoc.getElementById('root');
                    if (rootElement) {
                      const IframeReactDOM = (iframeWindow as any).ReactDOM;
                      const root = IframeReactDOM.createRoot(rootElement);
                      root.render(React.createElement(Component));
                    }

                    setRenderError(null);
                  }
                } catch (error) {
                  console.error('Render error:', error);
                  setRenderError(error instanceof Error ? error.message : String(error));
                }

                return null;
              }}
            </FrameContextConsumer>
          </Frame>
        </div>
      </div>

      {renderError && (
        <div style={{
          padding: "10px",
          background: "#fef2f2",
          color: "#991b1b",
          fontSize: "12px",
          fontFamily: "monospace",
          whiteSpace: "pre-wrap"
        }}>
          {renderError}
        </div>
      )}
    </div>
  );

  const canSend = inputValue.trim() && !isSending;

  // ChatGPT-like interface
  return (
    <div style={{
      display: "flex",
      flexDirection: "column",
      height: "100vh",
      background: "#ffffff",
      fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif"
    }}>
      <style>{`
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        @keyframes pulse {
          0%, 100% { opacity: 0.4; }
          50% { opacity: 1; }
        }
        .typing-dot {
          width: 8px;
          height: 8px;
          background: #666;
          border-radius: 50%;
          display: inline-block;
          margin: 0 2px;
          animation: pulse 1.4s infinite;
        }
        .typing-dot:nth-child(2) {
          animation-delay: 0.2s;
        }
        .typing-dot:nth-child(3) {
          animation-delay: 0.4s;
        }
      `}</style>

      {/* Messages Area */}
      <div style={{
        flex: 1,
        overflowY: "auto",
        padding: "20px",
        maxWidth: "800px",
        width: "100%",
        margin: "0 auto"
      }}>
        {messages.length === 0 ? (
          <div style={{
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            height: "100%",
            textAlign: "center",
            color: "#666"
          }}>
            <h1 style={{ fontSize: "32px", fontWeight: "600", marginBottom: "16px" }}>
              SlideStorm
            </h1>
            <p style={{ fontSize: "16px", marginBottom: "32px" }}>
              Create beautiful slides with AI
            </p>
            <div style={{ fontSize: "14px", color: "#999" }}>
              <p>Start by describing what slides you'd like to create</p>
              {pdfFile && (
                <p style={{ marginTop: "8px", color: "#4caf50" }}>
                  âœ“ Template: {pdfFile.name}
                </p>
              )}
            </div>
          </div>
        ) : (
          <>
            {messages.map((msg) => (
              <div
                key={msg.id}
                style={{
                  display: "flex",
                  marginBottom: "24px",
                  justifyContent: msg.role === 'user' ? 'flex-end' : 'flex-start'
                }}
              >
                <div style={{
                  maxWidth: "70%",
                  background: msg.role === 'user' ? '#f3f4f6' : 'transparent',
                  padding: msg.role === 'user' ? "12px 16px" : "12px 0",
                  borderRadius: "18px",
                  fontSize: "15px",
                  lineHeight: "1.5",
                  color: "#1f2937"
                }}>
                  {msg.role === 'assistant' && (
                    <div style={{
                      fontWeight: "600",
                      marginBottom: "8px",
                      fontSize: "14px",
                      color: "#10a37f"
                    }}>
                      SlideStorm
                    </div>
                  )}
                  {msg.isGenerating ? (
                    <div>
                      <span className="typing-dot"></span>
                      <span className="typing-dot"></span>
                      <span className="typing-dot"></span>
                    </div>
                  ) : (
                    <>
                      <div style={{ whiteSpace: "pre-wrap" }}>{msg.content}</div>
                      {msg.hasSlides && tsxFileContent && <SlidesViewer />}
                    </>
                  )}
                </div>
              </div>
            ))}
            <div ref={messagesEndRef} />
          </>
        )}
      </div>

      {/* Input Area */}
      <div style={{
        borderTop: "1px solid #e5e7eb",
        padding: "20px",
        background: "#ffffff"
      }}>
        <div style={{
          maxWidth: "800px",
          margin: "0 auto"
        }}>
          {/* Template Upload */}
          {!pdfFile && (
            <div style={{ marginBottom: "12px" }}>
              <label style={{
                display: "inline-flex",
                alignItems: "center",
                padding: "8px 16px",
                background: "#f3f4f6",
                borderRadius: "8px",
                fontSize: "14px",
                cursor: "pointer",
                color: "#374151"
              }}>
                <span style={{ marginRight: "8px" }}>ðŸ“Ž</span>
                {isConverting ? 'Converting...' : 'Add template (optional)'}
                <input
                  type="file"
                  accept="application/pdf,image/png,application/vnd.ms-powerpoint,application/vnd.openxmlformats-officedocument.presentationml.presentation"
                  onChange={handleFileSelect}
                  disabled={isConverting}
                  style={{ display: "none" }}
                />
              </label>
            </div>
          )}

          {pdfFile && (
            <div style={{
              marginBottom: "12px",
              padding: "8px 12px",
              background: "#f0fdf4",
              borderRadius: "8px",
              fontSize: "13px",
              color: "#15803d",
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between"
            }}>
              <span>âœ“ {pdfFile.name} ({pngFiles.length} page{pngFiles.length > 1 ? 's' : ''})</span>
              <button
                onClick={() => {
                  setPdfFile(null);
                  setPngFiles([]);
                }}
                style={{
                  background: "transparent",
                  border: "none",
                  cursor: "pointer",
                  fontSize: "16px",
                  padding: "0 4px"
                }}
              >
                Ã—
              </button>
            </div>
          )}

          {error && (
            <div style={{
              marginBottom: "12px",
              padding: "12px",
              background: "#fef2f2",
              borderRadius: "8px",
              fontSize: "13px",
              color: "#991b1b"
            }}>
              {error}
            </div>
          )}

          {/* Input Box */}
          <div style={{
            display: "flex",
            gap: "8px",
            alignItems: "flex-end"
          }}>
            <textarea
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && !e.shiftKey && canSend) {
                  e.preventDefault();
                  handleSend();
                }
              }}
              placeholder="Describe the slides you want to create..."
              style={{
                flex: 1,
                padding: "12px 16px",
                border: "1px solid #d1d5db",
                borderRadius: "12px",
                fontSize: "15px",
                fontFamily: "inherit",
                resize: "none",
                minHeight: "52px",
                maxHeight: "200px",
                outline: "none",
                boxShadow: "0 1px 2px rgba(0, 0, 0, 0.05)"
              }}
              rows={1}
            />
            <button
              onClick={handleSend}
              disabled={!canSend}
              style={{
                padding: "12px 20px",
                background: canSend ? "#10a37f" : "#d1d5db",
                color: "white",
                border: "none",
                borderRadius: "12px",
                fontSize: "15px",
                fontWeight: "500",
                cursor: canSend ? "pointer" : "not-allowed",
                transition: "background 0.2s",
                minWidth: "80px"
              }}
            >
              {isSending ? '...' : 'Send'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

export default PdfUploader;
mountWidget(<PdfUploader />);